* 6809 assembly program generated by cmoc 0.1.85


	SECTION	code


_NO_NODE	IMPORT
_memory	IMPORT
_lastIndex	IMPORT
_occurences	IMPORT
_occurencesCount	IMPORT
_rootNode	IMPORT
_dictionary	IMPORT
_occurences	EXPORT
_occurencesCount	EXPORT
_rootNode	EXPORT
_dictionary	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_addChildLeft	IMPORT
_addChildRight	IMPORT
_adddww	IMPORT
_atoff	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_bsearch	IMPORT
_changePrintfFormat	IMPORT
_cmpdww	IMPORT
_createNode	IMPORT
_debugTree	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_ftoa	IMPORT
_getLastIndex	IMPORT
_getNode	IMPORT
_initBitField	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_logOut	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readbits	IMPORT
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strreplace	IMPORT
_strstr	IMPORT
_strtof	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_treeInit	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_writebits	IMPORT
_zerodw	IMPORT
_stopIfCharOnLeaf	EXPORT


*******************************************************************************

* FUNCTION stopIfCharOnLeaf(): defined at Huffman.c:18
_stopIfCharOnLeaf	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: n: struct NODE_STRUCT *
*      6,U:    2 bytes: ch: void *
* Line Huffman.c:20: if
	LDD	6,U		variable `ch', declared at Huffman.c:18
* Emitted no code to cast `void *' to `unsigned char *'
	TFR	D,X
	LDB	,X		indirection
	PSHS	B
	LDX	4,U		variable n
	LDD	3,X		member pValue of NODE_STRUCT
* Emitted no code to cast `void *' to `struct VALUE_STRUCT *'
	TFR	D,X
	LDB	4,X		member ch of VALUE_STRUCT
	CMPB	,S+		compare with LSB
	BNE	L00130		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00131 removed
	CLRA
* optim: removeUselessClrb
* Emitted no code to cast `int' to `void *'
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable n
	LDD	5,X		member left of NODE_STRUCT
* optim: loadCmpZeroBeqOrBne
	BNE	L00130		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00132 removed
	CLRA
* optim: removeUselessClrb
* Emitted no code to cast `int' to `void *'
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable n
	LDD	7,X		member right of NODE_STRUCT
* optim: loadCmpZeroBeqOrBne
	BNE	L00130		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00129 removed
* Line Huffman.c:20
	LDB	#1
	BRA	L00100		return (Huffman.c:22)
* optim: instrFollowingUncondBranch
L00130	EQU	*		else clause of if() started at Huffman.c:20
* Line Huffman.c:23
	CLRB
	BRA	L00100		return (Huffman.c:25)
* Useless label L00133 removed
L00100	EQU	*		end of stopIfCharOnLeaf()
	LEAS	,U
	PULS	U,PC
* END FUNCTION stopIfCharOnLeaf(): defined at Huffman.c:18
funcend_stopIfCharOnLeaf	EQU *
funcsize_stopIfCharOnLeaf	EQU	funcend_stopIfCharOnLeaf-_stopIfCharOnLeaf
_huffInit	EXPORT


*******************************************************************************

* FUNCTION huffInit(): defined at Huffman.c:29
_huffInit	EQU	*
* Calling convention: Default
* Line Huffman.c:31: function call: treeInit()
	LBSR	_treeInit
* Line Huffman.c:32: function call: memset()
	LDD	#$09FB		constant expression: 2555 decimal, unsigned
	PSHS	B,A		argument 3 of memset(): unsigned int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LEAX	_occurences+0,PCR	address of array occurences
	PSHS	X		argument 1 of memset(): struct VALUE_STRUCT[]
	LBSR	_memset
	LEAS	6,S
* Line Huffman.c:35: function call: logOut()
	LDD	#$09FB		constant expression: 2555 decimal, unsigned
	PSHS	B,A		argument 3 of logOut(): unsigned int
	LEAX	S00116,PCR	"occurences array memory size:%d bytes"
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	6,S
* Line Huffman.c:36: function call: logOut()
	LDD	#$0500		constant expression: 1280 decimal, unsigned
	PSHS	B,A		argument 3 of logOut(): unsigned int
	LEAX	S00117,PCR	"dictionary array memory size:%d bytes"
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	6,S
* Useless label L00101 removed
	RTS
* END FUNCTION huffInit(): defined at Huffman.c:29
funcend_huffInit	EQU *
funcsize_huffInit	EQU	funcend_huffInit-_huffInit
_findOccurences	EXPORT


*******************************************************************************

* FUNCTION findOccurences(): defined at Huffman.c:39
_findOccurences	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-6,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: unsigned int
* Local non-static variable(s):
*     -6,U:    4 bytes: $V00121: unsigned long
*     -2,U:    2 bytes: i: int
* Line Huffman.c:41: for init
* Line Huffman.c:41: init of variable i
	CLRA
	CLRB
	STD	-2,U		variable i
	BRA	L00135		jump to for condition
L00134	EQU	*
* Line Huffman.c:41: for body
* Line Huffman.c:43: post-increment
	LDD	-2,U		variable i
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
* optim: stripOpToDeadReg
	LDA	#5		size of array element
	MUL			get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	PSHS	X		preserve address of number to inc/dec
	TFR	X,D
	LEAX	-6,U		temporary that receives init value of inc/dec
	LBSR	copyDWord
	PULS	X		point to number to inc/dec
	LBSR	incrementDWord	inc/dec number at X
* optim: removeUnusedLoad
* Line Huffman.c:44: assignment: =
	LDD	-2,U		variable i
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-2,U		variable i
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
* optim: stripOpToDeadReg
	LDA	#5		size of array element
	MUL			get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
* optim: optimizeLeax
	LDB	,S+
	STB	4,X		optim: optimizeLeax
* Useless label L00136 removed
* Line Huffman.c:41: for increment(s)
	LDD	-2,U
	ADDD	#1
	STD	-2,U
L00135	EQU	*
* Line Huffman.c:41: for condition
	LDD	-2,U		variable i
	CMPD	6,U		variable iSize
	BLO	L00134
* optim: branchToNextLocation
* Useless label L00137 removed
* Useless label L00102 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION findOccurences(): defined at Huffman.c:39
funcend_findOccurences	EQU *
funcsize_findOccurences	EQU	funcend_findOccurences-_findOccurences
_compareLong	EXPORT


*******************************************************************************

* FUNCTION compareLong(): defined at Huffman.c:48
_compareLong	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-32,S
* Formal parameter(s):
*      4,U:    4 bytes: a: long
*      8,U:    4 bytes: b: long
* Local non-static variable(s):
*    -32,U:    2 bytes: la: unsigned int
*    -30,U:    2 bytes: lb: unsigned int
*    -28,U:    2 bytes: ra: unsigned int
*    -26,U:    2 bytes: rb: unsigned int
*    -24,U:    4 bytes: $V00122: long
*    -20,U:    4 bytes: $V00123: long
*    -16,U:    4 bytes: $V00124: long
*    -12,U:    4 bytes: $V00125: long
*     -8,U:    4 bytes: $V00126: long
*     -4,U:    4 bytes: $V00127: long
* Line Huffman.c:50: init of variable la
	CLRA
	LDB	#$10		decimal 16 signed
	LDA	#$FF		request sign extension
	PSHS	B,A		A=sign/zero ext flag, B=number of bits to shift
	LEAY	D00138,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	4,U		variable `a', declared at Huffman.c:48
	PSHS	Y,X		optim: optimizePshsOps
	LEAX	-20,U		temporary destination, type long
	LBSR	andDWordDWord	preserves X
	LEAS	4,S
	PSHS	X		address of input dword to be shifted
	LEAX	-24,U		temporary destination, type long
	LBSR	rightShiftDWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-32,U		variable la
* Line Huffman.c:51: init of variable lb
	CLRA
	LDB	#$10		decimal 16 signed
	LDA	#$FF		request sign extension
	PSHS	B,A		A=sign/zero ext flag, B=number of bits to shift
	LEAY	D00138,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	8,U		variable `b', declared at Huffman.c:48
	PSHS	Y,X		optim: optimizePshsOps
	LEAX	-12,U		temporary destination, type long
	LBSR	andDWordDWord	preserves X
	LEAS	4,S
	PSHS	X		address of input dword to be shifted
	LEAX	-16,U		temporary destination, type long
	LBSR	rightShiftDWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-30,U		variable lb
* Line Huffman.c:52: init of variable ra
	LDD	#$FFFF		decimal 65535 unsigned
	PSHS	B,A
	LEAX	4,U		variable `a', declared at Huffman.c:48
	PSHS	X
	LEAX	-8,U		temporary destination, type long
	LBSR	andDWordWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-28,U		variable ra
* Line Huffman.c:53: init of variable rb
	LDD	#$FFFF		decimal 65535 unsigned
	PSHS	B,A
	LEAX	8,U		variable `b', declared at Huffman.c:48
	PSHS	X
	LEAX	-4,U		temporary destination, type long
	LBSR	andDWordWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-26,U		variable rb
* Line Huffman.c:55: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BLS	L00140		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00139 removed
* Line Huffman.c:55
	LDB	#1
	BRA	L00103		return (Huffman.c:55)
L00140	EQU	*		else clause of if() started at Huffman.c:55
* Useless label L00141 removed
* Line Huffman.c:56: if
	LDD	-30,U		variable lb
	CMPD	-32,U		variable la
	BLS	L00143		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00142 removed
* Line Huffman.c:56
	LDB	#255
	BRA	L00103		return (Huffman.c:56)
L00143	EQU	*		else clause of if() started at Huffman.c:56
* Useless label L00144 removed
* Line Huffman.c:57: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BNE	L00146		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00147 removed
	LDD	-28,U		variable ra
	CMPD	-26,U		variable rb
	BLS	L00146		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00145 removed
* Line Huffman.c:57
	LDB	#1
	BRA	L00103		return (Huffman.c:57)
L00146	EQU	*		else clause of if() started at Huffman.c:57
* Useless label L00148 removed
* Line Huffman.c:58: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BNE	L00150		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00151 removed
	LDD	-28,U		variable ra
	CMPD	-26,U		variable rb
	BHS	L00150		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00149 removed
* Line Huffman.c:58
	LDB	#255
	BRA	L00103		return (Huffman.c:58)
L00150	EQU	*		else clause of if() started at Huffman.c:58
* Useless label L00152 removed
* Line Huffman.c:59: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BNE	L00154		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00155 removed
	LDD	-28,U		variable ra
	CMPD	-26,U		variable rb
	BNE	L00154		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00153 removed
* Line Huffman.c:59
	CLRB
	BRA	L00103		return (Huffman.c:59)
L00154	EQU	*		else clause of if() started at Huffman.c:59
* Useless label L00156 removed
	LDB	#2
* optim: branchToNextLocation
L00103	EQU	*		end of compareLong()
	LEAS	,U
	PULS	U,PC
* END FUNCTION compareLong(): defined at Huffman.c:48
funcend_compareLong	EQU *
funcsize_compareLong	EQU	funcend_compareLong-_compareLong
_getUsedNodes	EXPORT


*******************************************************************************

* FUNCTION getUsedNodes(): defined at Huffman.c:64
_getUsedNodes	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      4,U:    2 bytes: queue: struct NODE_STRUCT **
*      6,U:    2 bytes: occCount: unsigned int
* Local non-static variable(s):
*     -4,U:    2 bytes: i: unsigned int
*     -2,U:    2 bytes: u: int
* Line Huffman.c:66: init of variable u
	CLRA
	CLRB
	STD	-2,U		variable u
* Line Huffman.c:67: for init
* Line Huffman.c:67: init of variable i
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-4,U		variable i
	BRA	L00158		jump to for condition
L00157	EQU	*
* Line Huffman.c:67: for body
* Line Huffman.c:68: if
	LDD	-4,U		variable i
	LSLB
	ROLA
	LDX	4,U		pointer queue
	LEAX	D,X		add offset
* optim: optimizeLdx
* optim: removeTfrDX
	LDB	[,X]		optim: optimizeLdx
* optim: loadCmpZeroBeqOrBne
	BEQ	L00162		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00161 removed
* Line Huffman.c:68
* Line Huffman.c:69: post-increment
	LDX	-2,U		variable `u', declared at Huffman.c:69
	LEAX	1,X
	STX	-2,U
L00162	EQU	*		else clause of if() started at Huffman.c:68
* Useless label L00163 removed
* Useless label L00159 removed
* Line Huffman.c:67: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00158	EQU	*
* Line Huffman.c:67: for condition
	LDD	-4,U		variable i
	CMPD	6,U		variable occCount
	BLO	L00157
* optim: branchToNextLocation
* Useless label L00160 removed
* Line Huffman.c:72: return with value
	LDD	-2,U		variable `u', declared at Huffman.c:66
* Emitted no code to cast `int' to `unsigned int'
* optim: branchToNextLocation
* Useless label L00104 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION getUsedNodes(): defined at Huffman.c:64
funcend_getUsedNodes	EQU *
funcsize_getUsedNodes	EQU	funcend_getUsedNodes-_getUsedNodes
_findMinNode	EXPORT


*******************************************************************************

* FUNCTION findMinNode(): defined at Huffman.c:75
_findMinNode	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-8,S
* Formal parameter(s):
*      4,U:    2 bytes: queue: struct NODE_STRUCT **
*      6,U:    2 bytes: occCount: unsigned int
* Local non-static variable(s):
*     -8,U:    2 bytes: i: unsigned int
*     -6,U:    4 bytes: maxNode: unsigned long
*     -2,U:    2 bytes: minNodeIndex: unsigned int
* Line Huffman.c:77: init of variable maxNode
	LDD	#$FFFF		65535
	LEAX	-6,U		address of variable maxNode
	LBSR	initDWordFromSignedWord
* Line Huffman.c:78: init of variable minNodeIndex
	CLRA
	CLRB
	STD	-2,U		variable minNodeIndex
* Line Huffman.c:79: for init
* Line Huffman.c:79: init of variable i
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-8,U		variable i
	LBRA	L00165		jump to for condition
L00164	EQU	*
* Line Huffman.c:79: for body
* Line Huffman.c:80: if
	LDD	-8,U		variable i
	LSLB
	ROLA
	LDX	4,U		pointer queue
	LEAX	D,X		add offset
* optim: optimizeLdx
* optim: removeTfrDX
	LDB	[,X]		optim: optimizeLdx
* optim: loadCmpZeroBeqOrBne
	BEQ	L00169		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00170 removed
* Line Huffman.c:80: function call: compareLong()
	LEAX	-6,U		variable `maxNode', declared at Huffman.c:77
	LEAS	-4,S		pass unsigned long by value
	LBSR	push4ByteStruct	argument 2 of compareLong(): unsigned long
	LDD	-8,U		variable i
	LSLB
	ROLA
	LDX	4,U		pointer queue
	LEAX	D,X		add offset
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	3,X		member pValue of NODE_STRUCT
* Emitted no code to cast `void *' to `unsigned long *'
	TFR	D,X
	LEAS	-4,S		pass unsigned long by value
	LBSR	push4ByteStruct	argument 1 of compareLong(): unsigned long
	LBSR	_compareLong
	LEAS	8,S
	CMPB	#255
	BNE	L00169		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00168 removed
* Line Huffman.c:80
* Line Huffman.c:81: assignment: =
	LDD	-8,U		variable i
	LSLB
	ROLA
	LDX	4,U		pointer queue
	LEAX	D,X		add offset
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	3,X		member pValue of NODE_STRUCT
* Emitted no code to cast `void *' to `unsigned long *'
* optim: removeUselessTfr1
* optim: stripConsecOppositeTFRs
	LEAX	-6,U		variable `maxNode', declared at Huffman.c:77
	LBSR	copyDWord	copy 4-byte struct (preserves X)
* Line Huffman.c:82: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-8,U
	STD	-2,U
L00169	EQU	*		else clause of if() started at Huffman.c:80
* Useless label L00171 removed
* Useless label L00166 removed
* Line Huffman.c:79: for increment(s)
	LDD	-8,U
	ADDD	#1
	STD	-8,U
L00165	EQU	*
* Line Huffman.c:79: for condition
	LDD	-8,U		variable i
	CMPD	6,U		variable occCount
	LBLO	L00164
* optim: branchToNextLocation
* Useless label L00167 removed
* Line Huffman.c:85: return with value
	LDD	-2,U		variable `minNodeIndex', declared at Huffman.c:78
* optim: branchToNextLocation
* Useless label L00105 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION findMinNode(): defined at Huffman.c:75
funcend_findMinNode	EQU *
funcsize_findMinNode	EQU	funcend_findMinNode-_findMinNode
_createTree	EXPORT


*******************************************************************************

* FUNCTION createTree(): defined at Huffman.c:88
_createTree	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-1038,S
* Local non-static variable(s):
*  -1038,U:    2 bytes: maxNodeIndexFirst: unsigned int
*  -1036,U:    2 bytes: u: unsigned int
*  -1034,U:    2 bytes: maxNodeIndexSecond: unsigned int
*  -1032,U:    2 bytes: parent: struct NODE_STRUCT *
*  -1030,U:    2 bytes: i: int
*  -1028,U:    2 bytes: j: int
*  -1026,U:    2 bytes: occCount: unsigned int
*  -1024,U:    2 bytes: parentOccIdx: unsigned int
*  -1022,U: 1022 bytes: queue: struct NODE_STRUCT *[]
* Line Huffman.c:90: init of variable occCount
	CLRA
	CLRB
	STD	-1026,U		variable occCount
* Line Huffman.c:91: init of variable parentOccIdx
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-1024,U		variable parentOccIdx
* Line Huffman.c:94: for init
* Line Huffman.c:94: init of variable i
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-1030,U		variable i
* Line Huffman.c:94: init of variable j
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-1028,U		variable j
	BRA	L00173		jump to for condition
L00172	EQU	*
* Line Huffman.c:94: for body
* Line Huffman.c:95: if
	LDX	-1030,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LBSR	isDWordZero
	BEQ	L00177
* optim: branchToNextLocation
* Useless label L00176 removed
* Line Huffman.c:95
* Line Huffman.c:97: assignment: =
* Line Huffman.c:97: function call: createNode()
	LDX	-1030,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	TFR	X,D		address-of operator
* Emitted no code to cast `struct VALUE_STRUCT *' to `void *'
	PSHS	B,A		argument 1 of createNode(): void *
	LBSR	_createNode
	LEAS	2,S
	PSHS	B,A
	LDD	-1028,U		variable `j', declared at Huffman.c:97
	ADDD	#1
	STD	-1028,U
	SUBD	#1		post increment yields initial value
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line Huffman.c:98: post-increment
	LDX	-1026,U		variable `occCount', declared at Huffman.c:98
	LEAX	1,X
	STX	-1026,U
L00177	EQU	*		else clause of if() started at Huffman.c:95
* Useless label L00178 removed
* Useless label L00174 removed
* Line Huffman.c:94: for increment(s)
	LDD	-1030,U
	ADDD	#1
	STD	-1030,U
L00173	EQU	*
* Line Huffman.c:94: for condition
	LDD	-1030,U		variable i
	CMPD	#$0100
	BLT	L00172
* optim: branchToNextLocation
* Useless label L00175 removed
* Line Huffman.c:103: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-1026,U
	STD	_occurencesCount+0,PCR
* Line Huffman.c:109: while
	LBRA	L00180		jump to while condition
L00179	EQU	*		while body
* Line Huffman.c:112: init of variable maxNodeIndexFirst
* Line Huffman.c:112: function call: findMinNode()
	LDD	-1026,U		variable `occCount', declared at Huffman.c:90
	PSHS	B,A		argument 2 of findMinNode(): unsigned int
	LEAX	-1022,U		address of array queue
	PSHS	X		argument 1 of findMinNode(): struct NODE_STRUCT *[]
	LBSR	_findMinNode
	LEAS	4,S
	STD	-1038,U		variable maxNodeIndexFirst
* Line Huffman.c:114: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDD	-1038,U		variable maxNodeIndexFirst
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
* optim: optimizeLdx
* optim: removeTfrDX
	LDB	,S+
	STB	[,X]		optim: optimizeLdx
* Line Huffman.c:117: init of variable u
* Line Huffman.c:117: function call: getUsedNodes()
	LDD	-1026,U		variable `occCount', declared at Huffman.c:90
	PSHS	B,A		argument 2 of getUsedNodes(): unsigned int
	LEAX	-1022,U		address of array queue
	PSHS	X		argument 1 of getUsedNodes(): struct NODE_STRUCT *[]
	LBSR	_getUsedNodes
	LEAS	4,S
	STD	-1036,U		variable u
* Line Huffman.c:119: init of variable maxNodeIndexSecond
* Line Huffman.c:119: function call: findMinNode()
	LDD	-1026,U		variable `occCount', declared at Huffman.c:90
	PSHS	B,A		argument 2 of findMinNode(): unsigned int
	LEAX	-1022,U		address of array queue
	PSHS	X		argument 1 of findMinNode(): struct NODE_STRUCT *[]
	LBSR	_findMinNode
	LEAS	4,S
	STD	-1034,U		variable maxNodeIndexSecond
* Line Huffman.c:120: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDD	-1034,U		variable maxNodeIndexSecond
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
* optim: optimizeLdx
* optim: removeTfrDX
	LDB	,S+
	STB	[,X]		optim: optimizeLdx
* Line Huffman.c:126: assignment: =
* Push right operand of add.
	LDD	-1034,U		variable maxNodeIndexSecond
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	3,X		member pValue of NODE_STRUCT
* Emitted no code to cast `void *' to `struct VALUE_STRUCT *'
	TFR	D,X
	PSHS	X
* Push left operand of add.
	LDD	-1038,U		variable maxNodeIndexFirst
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	3,X		member pValue of NODE_STRUCT
* Emitted no code to cast `void *' to `struct VALUE_STRUCT *'
	TFR	D,X
	PSHS	X
	LEAX	-1030,U		temporary destination, type unsigned long
	LBSR	addDWordDWord	preserves X
	LEAS	4,S
	PSHS	X		source struct
	LDD	-1024,U		variable parentOccIdx
	ADDD	#$0100		256
	LDX	#5		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	PULS	A,B		source struct
	LBSR	copyDWord	copy 4-byte struct (preserves X)
* Line Huffman.c:127: init of variable parent
* Line Huffman.c:127: function call: createNode()
	LDD	-1024,U		variable `parentOccIdx', declared at Huffman.c:127
	ADDD	#1
	STD	-1024,U
* optim: combineConsecutiveOps
	ADDD	#$FF		optim: combineConsecutiveOps
* 
* 
	LDX	#5		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	TFR	X,D		address-of operator
* Emitted no code to cast `struct VALUE_STRUCT *' to `void *'
	PSHS	B,A		argument 1 of createNode(): void *
	LBSR	_createNode
	LEAS	2,S
	STD	-1032,U		variable parent
* Line Huffman.c:128: function call: addChildLeft()
	LDD	-1038,U		variable maxNodeIndexFirst
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	LDD	,X		get r-value
	PSHS	B,A		argument 2 of addChildLeft(): struct NODE_STRUCT *
	LDD	-1032,U		variable `parent', declared at Huffman.c:127
	PSHS	B,A		argument 1 of addChildLeft(): struct NODE_STRUCT *
	LBSR	_addChildLeft
	LEAS	4,S
* Line Huffman.c:130: if
	LDD	-1036,U		variable `u', declared at Huffman.c:117
* optim: loadCmpZeroBeqOrBne
	BNE	L00183		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00182 removed
* Line Huffman.c:130
* Line Huffman.c:132: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-1032,U
	STD	_rootNode+0,PCR
	BRA	L00181		break
L00183	EQU	*		else clause of if() started at Huffman.c:130
* Useless label L00184 removed
* Line Huffman.c:136: function call: addChildRight()
	LDD	-1034,U		variable maxNodeIndexSecond
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	LDD	,X		get r-value
	PSHS	B,A		argument 2 of addChildRight(): struct NODE_STRUCT *
	LDD	-1032,U		variable `parent', declared at Huffman.c:127
	PSHS	B,A		argument 1 of addChildRight(): struct NODE_STRUCT *
	LBSR	_addChildRight
	LEAS	4,S
* Line Huffman.c:137: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-1032,U
	STD	_rootNode+0,PCR
* Line Huffman.c:139: assignment: =
* Line Huffman.c:139: function call: getUsedNodes()
	LDD	-1026,U		variable `occCount', declared at Huffman.c:90
	PSHS	B,A		argument 2 of getUsedNodes(): unsigned int
	LEAX	-1022,U		address of array queue
	PSHS	X		argument 1 of getUsedNodes(): struct NODE_STRUCT *[]
	LBSR	_getUsedNodes
	LEAS	4,S
	STD	-1036,U
* Line Huffman.c:140: if
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	BEQ	L00181		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00185 removed
* Line Huffman.c:140
* optim: condBranchOverUncondBranch
* Useless label L00186 removed
* Useless label L00187 removed
* Line Huffman.c:146: assignment: =
	LDD	-1032,U		variable `parent', declared at Huffman.c:127
	PSHS	B,A
	LDD	-1026,U		variable `occCount', declared at Huffman.c:146
	ADDD	#1
	STD	-1026,U
	SUBD	#1		post increment yields initial value
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
L00180	EQU	*		while condition at Huffman.c:109
	LBRA	L00179		go to start of while body
L00181	EQU	*		after end of while starting at Huffman.c:109
* Line Huffman.c:150: for init
* Line Huffman.c:150: init of variable i
	CLRA
	CLRB
	STD	-1028,U		variable i
	BRA	L00189		jump to for condition
L00188	EQU	*
* Line Huffman.c:151: for body
* Line Huffman.c:151: assignment: =
	CLRA
	CLRB
* Emitted no code to cast `int' to `void *'
	PSHS	B,A
	LDD	-1028,U		variable i
	LSLB
	ROLA
	LEAX	-1022,U		address of array queue
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Useless label L00190 removed
* Line Huffman.c:150: for increment(s)
	LDD	-1028,U
	ADDD	#1
	STD	-1028,U
L00189	EQU	*
* Line Huffman.c:150: for condition
	LDD	-1028,U		variable i
	CMPD	#$01FF
	BLT	L00188
* optim: branchToNextLocation
* Useless label L00191 removed
* Useless label L00106 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION createTree(): defined at Huffman.c:88
funcend_createTree	EQU *
funcsize_createTree	EQU	funcend_createTree-_createTree
_findPath	EXPORT


*******************************************************************************

* FUNCTION findPath(): defined at Huffman.c:156
_findPath	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      4,U:    2 bytes: startNode: struct NODE_STRUCT *
*      6,U:    2 bytes: arg: void *
*      8,U:    2 bytes: fp: char (*)(struct NODE_STRUCT *, void *)
*     10,U:    2 bytes: resultPath: unsigned char *
*     12,U:    2 bytes: resultPathSize: unsigned char *
*     14,U:    2 bytes: stopRecursion: char *
* Local non-static variable(s):
*     -3,U:    2 bytes: hb: struct HARVEST_BITS_STRUCT *
*     -1,U:    1 byte : stop: char
* Line Huffman.c:158: if
	LDD	4,U		variable `startNode', declared at Huffman.c:156
* optim: loadCmpZeroBeqOrBne
	LBEQ	L00107		 (optim: condBranchOverUncondBranch)
* optim: branchToNextLocation
* Useless label L00192 removed
* Line Huffman.c:158
* optim: condBranchOverUncondBranch
* Useless label L00193 removed
* Useless label L00194 removed
* Line Huffman.c:159: if
	LDB	[14,U]		indirection
* optim: loadCmpZeroBeqOrBne
	LBNE	L00107		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00195 removed
* Line Huffman.c:159
* optim: condBranchOverUncondBranch
* Useless label L00196 removed
* Useless label L00197 removed
* Line Huffman.c:160: init of variable hb
	LDD	6,U		variable `arg', declared at Huffman.c:156
* Emitted no code to cast `void *' to `struct HARVEST_BITS_STRUCT *'
	STD	-3,U		variable hb
* Line Huffman.c:161: init of variable stop
* Line Huffman.c:161: function call through pointer
	LDD	6,U		variable `arg', declared at Huffman.c:156
	PSHS	B,A		argument 2: void *
	LDD	4,U		variable `startNode', declared at Huffman.c:156
	PSHS	B,A		argument 1: struct NODE_STRUCT *
	JSR	[8,U]		indirect call through variable `fp'
	LEAS	4,S
	STB	-1,U		variable stop
* Line Huffman.c:162: if
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	LBNE	L00199
* optim: branchToNextLocation
* Useless label L00198 removed
* Line Huffman.c:162
* Line Huffman.c:163: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDX	-3,U		variable hb
	LDB	33,X		member size of HARVEST_BITS_STRUCT
* optim: stripExtraClrA_B
	PSHS	B,A		preserve array index
	LDX	-3,U		variable hb
	LEAX	1,X		member path of HARVEST_BITS_STRUCT
	TFR	X,D
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Line Huffman.c:164: post-increment
	LDX	-3,U		variable hb
* optim: optimizeLeax
	INC	33,X		optim: optimizeLeax
* Line Huffman.c:165: function call: findPath()
	LDY	14,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	12,U		optim: transformPshsDPshsD
	PSHS	Y,X		optim: optimizePshsOps
	LDY	10,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable `arg', declared at Huffman.c:156
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LDX	4,U		variable startNode
	LDD	5,X		member left of NODE_STRUCT
	PSHS	B,A		argument 1 of findPath(): struct NODE_STRUCT *
	LBSR	_findPath
	LEAS	12,S
* Line Huffman.c:166: post-decrement
	LDX	-3,U		variable hb
* optim: optimizeLeax
	DEC	33,X		optim: optimizeLeax
* Line Huffman.c:167: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDX	-3,U		variable hb
	LDB	33,X		member size of HARVEST_BITS_STRUCT
* optim: stripExtraClrA_B
	PSHS	B,A		preserve array index
	LDX	-3,U		variable hb
	LEAX	1,X		member path of HARVEST_BITS_STRUCT
	TFR	X,D
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Line Huffman.c:168: post-increment
	LDX	-3,U		variable hb
* optim: optimizeLeax
	INC	33,X		optim: optimizeLeax
* Line Huffman.c:169: function call: findPath()
	LDY	14,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	12,U		optim: transformPshsDPshsD
	PSHS	Y,X		optim: optimizePshsOps
	LDY	10,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable `arg', declared at Huffman.c:156
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LDX	4,U		variable startNode
	LDD	7,X		member right of NODE_STRUCT
	PSHS	B,A		argument 1 of findPath(): struct NODE_STRUCT *
	LBSR	_findPath
	LEAS	12,S
* Line Huffman.c:170: post-decrement
	LDX	-3,U		variable hb
* optim: optimizeLeax
	DEC	33,X		optim: optimizeLeax
	BRA	L00200		jump over else clause
L00199	EQU	*		else clause of if() started at Huffman.c:162
* Line Huffman.c:171
* Line Huffman.c:172: assignment: =
	LDX	-3,U		variable hb
	LDB	33,X		member size of HARVEST_BITS_STRUCT
* optim: stripExtraPushPullB
* optim: optimizeLdx
* optim: stripExtraPushPullB
	STB	[12,U]		optim: optimizeLdx
* Line Huffman.c:173: function call: memcpy()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		argument 3 of memcpy(): int
	LDX	-3,U		variable hb
	LEAX	1,X		member path of HARVEST_BITS_STRUCT
	TFR	X,D
	PSHS	B,A		argument 2 of memcpy(): unsigned char[]
	LDD	10,U		variable `resultPath', declared at Huffman.c:156
	PSHS	B,A		argument 1 of memcpy(): unsigned char *
	LBSR	_memcpy
	LEAS	6,S
* Line Huffman.c:174: post-increment
* optim: optimizeLdx
	INC	[14,U]		optim: optimizeLdx
	BRA	L00107		return (Huffman.c:175)
L00200	EQU	*		end of if() started at Huffman.c:162
L00107	EQU	*		end of findPath()
	LEAS	,U
	PULS	U,PC
* END FUNCTION findPath(): defined at Huffman.c:156
funcend_findPath	EQU *
funcsize_findPath	EQU	funcend_findPath-_findPath
_findDicCode	EXPORT


*******************************************************************************

* FUNCTION findDicCode(): defined at Huffman.c:180
_findDicCode	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-36,S
* Formal parameter(s):
*      5,U:    1 byte : ch: const unsigned char
*      6,U:    2 bytes: symbolCode: unsigned char *
* Local non-static variable(s):
*    -36,U:   34 bytes: hb: struct HARVEST_BITS_STRUCT
*     -2,U:    1 byte : resultPathSize: unsigned char
*     -1,U:    1 byte : stopRecursion: char
* Line Huffman.c:184: assignment: =
	LDB	5,U		variable `ch', declared at Huffman.c:180
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-36,U		optim: optimizeLeax
* Line Huffman.c:185: assignment: =
	CLRA
	CLRB
* optim: stripExtraPushPullB
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	-3,U		optim: optimizeLeax
* Line Huffman.c:187: init of variable stopRecursion
	CLR	-1,U		variable stopRecursion
* Line Huffman.c:188: function call: findPath()
	LEAY	-1,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-2,U		variable `resultPathSize', declared at Huffman.c:186
* optim: optimizePshsOps
	LDD	6,U		variable `symbolCode', declared at Huffman.c:180
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LEAX	_stopIfCharOnLeaf,PCR	address of stopIfCharOnLeaf(), defined at Huffman.c:18
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	-36,U		variable `hb', declared at Huffman.c:183
	TFR	X,D		address-of operator
* Emitted no code to cast `struct HARVEST_BITS_STRUCT *' to `void *'
	PSHS	B,A		argument 2 of findPath(): void *
	LDD	_rootNode+0,PCR	variable `rootNode', declared at Huffman.c:14
	PSHS	B,A		argument 1 of findPath(): struct NODE_STRUCT *
	LBSR	_findPath
	LEAS	12,S
* Line Huffman.c:194: return with value
	LDB	-2,U		variable `resultPathSize', declared at Huffman.c:186
* optim: branchToNextLocation
* Useless label L00108 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION findDicCode(): defined at Huffman.c:180
funcend_findDicCode	EQU *
funcsize_findDicCode	EQU	funcend_findDicCode-_findDicCode
_countBits	EXPORT


*******************************************************************************

* FUNCTION countBits(): defined at Huffman.c:197
_countBits	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : n: unsigned char
* Local non-static variable(s):
*     -1,U:    1 byte : count: unsigned char
* Line Huffman.c:199: init of variable count
	CLR	-1,U		variable count
* Line Huffman.c:200: while
	BRA	L00202		jump to while condition
L00201	EQU	*		while body
* Line Huffman.c:201: post-increment
	INC	-1,U
* Line Huffman.c:202: assignment: >>=
	LEAX	5,U		variable `n', declared at Huffman.c:197
	LDB	,X		get byte to be shifted
	LSRB
	STB	,X		store shifted byte
L00202	EQU	*		while condition at Huffman.c:200
	LDB	5,U		variable `n', declared at Huffman.c:197
* optim: loadCmpZeroBeqOrBne
	BNE	L00201
* optim: branchToNextLocation
* Useless label L00203 removed
* Line Huffman.c:204: return with value
	LDB	-1,U		variable `count', declared at Huffman.c:199
* optim: branchToNextLocation
* Useless label L00109 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION countBits(): defined at Huffman.c:197
funcend_countBits	EQU *
funcsize_countBits	EQU	funcend_countBits-_countBits
_updateDic	EXPORT


*******************************************************************************

* FUNCTION updateDic(): defined at Huffman.c:207
_updateDic	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-48,S
* Local non-static variable(s):
*    -48,U:    2 bytes: j: int
*    -46,U:    1 byte : symbolLen: unsigned char
*    -45,U:    2 bytes: i: int
*    -43,U:   32 bytes: symbolCode: unsigned char[]
*    -11,U:    1 byte : maxLen: unsigned char
*    -10,U:    1 byte : bitsReq: unsigned char
*     -9,U:    5 bytes: bf: struct bitFieldStruct
*     -4,U:    4 bytes: buffer: unsigned char[]
* Line Huffman.c:210: function call: logOut()
	LDD	_occurencesCount+0,PCR	variable `occurencesCount', declared at Huffman.c:13
	PSHS	B,A		argument 3 of logOut(): unsigned int
	LEAX	S00118,PCR	"occurences count:%d"
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	6,S
* Line Huffman.c:214: init of variable maxLen
	CLR	-11,U		variable maxLen
* Line Huffman.c:215: init of variable bitsReq
	CLR	-10,U		variable bitsReq
* Line Huffman.c:216: for init
* Line Huffman.c:216: init of variable i
	CLRA
	CLRB
	STD	-45,U		variable i
	BRA	L00205		jump to for condition
L00204	EQU	*
* Line Huffman.c:216: for body
* Line Huffman.c:217: if
	LDX	-45,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LBSR	isDWordZero
	BEQ	L00209
* optim: branchToNextLocation
* Useless label L00208 removed
* Line Huffman.c:217
* Line Huffman.c:218: init of variable symbolLen
* Line Huffman.c:218: function call: findDicCode()
	LEAX	-43,U		address of array symbolCode
	PSHS	X		argument 2 of findDicCode(): unsigned char[]
	LDX	-45,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of findDicCode(): unsigned char
	LBSR	_findDicCode
	LEAS	4,S
	STB	-46,U		variable symbolLen
* Line Huffman.c:219: if
* optim: storeLoad
	CMPB	-11,U		variable maxLen
	BLS	L00211		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00210 removed
* Line Huffman.c:220
* Line Huffman.c:220: assignment: =
	LDB	-46,U		variable `symbolLen', declared at Huffman.c:218
	STB	-11,U
L00211	EQU	*		else clause of if() started at Huffman.c:219
* Useless label L00212 removed
L00209	EQU	*		else clause of if() started at Huffman.c:217
* Useless label L00213 removed
* Useless label L00206 removed
* Line Huffman.c:216: for increment(s)
	LDD	-45,U
	ADDD	#1
	STD	-45,U
L00205	EQU	*
* Line Huffman.c:216: for condition
	LDD	-45,U		variable i
	CMPD	#$0100
	BLT	L00204
* optim: branchToNextLocation
* Useless label L00207 removed
* Line Huffman.c:223: assignment: =
* Line Huffman.c:223: function call: countBits()
	LDB	-11,U		variable `maxLen', declared at Huffman.c:214
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of countBits(): unsigned char
	LBSR	_countBits
	LEAS	2,S
	STB	-10,U
* Line Huffman.c:224: function call: logOut()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 4 of logOut(): unsigned char
	LDB	-11,U		variable `maxLen', declared at Huffman.c:214
* optim: stripExtraClrA_B
	PSHS	B,A		argument 3 of logOut(): unsigned char
	LEAX	S00119,PCR	"max length path:%d - bits required:%d"
* optim: optimizePshsOps
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	8,S
* Line Huffman.c:229: for init
* Line Huffman.c:229: init of variable i
	CLRA
	CLRB
	STD	-45,U		variable i
	LBRA	L00215		jump to for condition
L00214	EQU	*
* Line Huffman.c:229: for body
* Line Huffman.c:230: if
	LDX	-45,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LBSR	isDWordZero
	LBEQ	L00219
* optim: branchToNextLocation
* Useless label L00218 removed
* Line Huffman.c:230
* Line Huffman.c:231: function call: memset()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		argument 3 of memset(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LEAX	-4,U		address of array buffer
	PSHS	X		argument 1 of memset(): unsigned char[]
	LBSR	_memset
	LEAS	6,S
* Line Huffman.c:232: function call: initBitField()
	LEAY	-4,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-9,U		variable `bf', declared at Huffman.c:227
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line Huffman.c:235: init of variable symbolLen
* Line Huffman.c:235: function call: findDicCode()
	LEAX	-43,U		address of array symbolCode
	PSHS	X		argument 2 of findDicCode(): unsigned char[]
	LDX	-45,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of findDicCode(): unsigned char
	LBSR	_findDicCode
	LEAS	4,S
	STB	-46,U		variable symbolLen
* Line Huffman.c:237: for init
* Line Huffman.c:237: init of variable j
	CLRA
	CLRB
	STD	-48,U		variable j
	BRA	L00221		jump to for condition
L00220	EQU	*
* Line Huffman.c:237: for body
* Line Huffman.c:238: function call: writebits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDD	-48,U		variable j
	LEAX	-43,U		address of array symbolCode
* optimizeLoadDX
	LDB	D,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LEAX	-9,U		variable `bf', declared at Huffman.c:227
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Useless label L00222 removed
* Line Huffman.c:237: for increment(s)
	LDD	-48,U
	ADDD	#1
	STD	-48,U
L00221	EQU	*
* Line Huffman.c:237: for condition
	LDB	-46,U		variable `symbolLen', declared at Huffman.c:235
	CLRA			promotion of binary operand
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-48,U		optim: optimize16BitCompares
	BHI	L00220		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label L00223 removed
* Line Huffman.c:240: assignment: =
	LDB	-46,U		variable `symbolLen', declared at Huffman.c:235
	PSHS	B
	LDX	-45,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
* optim: stripOpToDeadReg
	LDA	#5		size of array element
	MUL			get offset in bytes in D
	LEAX	_dictionary+0,PCR	address of array dictionary
	LEAX	D,X		add offset
* optim: optimizeLeax
	LDB	,S+
	STB	4,X		optim: optimizeLeax
* Line Huffman.c:241: function call: memcpy()
	LDX	#$04		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-9,U		member buffer of bitFieldStruct, via variable bf
	PSHS	X,B,A		optim: optimizePshsOps
	LDX	-45,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
* optim: stripOpToDeadReg
	LDA	#5		size of array element
	MUL			get offset in bytes in D
	LEAX	_dictionary+0,PCR	address of array dictionary
	LEAX	D,X		add offset
	LEAX	,X		member code of DICTIONARY_STRUCT
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_memcpy
	LEAS	6,S
L00219	EQU	*		else clause of if() started at Huffman.c:230
* Useless label L00224 removed
* Useless label L00216 removed
* Line Huffman.c:229: for increment(s)
	LDD	-45,U
	ADDD	#1
	STD	-45,U
L00215	EQU	*
* Line Huffman.c:229: for condition
	LDD	-45,U		variable i
	CMPD	#$0100
	LBLT	L00214
* optim: branchToNextLocation
* Useless label L00217 removed
* Useless label L00110 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION updateDic(): defined at Huffman.c:207
funcend_updateDic	EQU *
funcsize_updateDic	EQU	funcend_updateDic-_updateDic
_computeDic	EXPORT


*******************************************************************************

* FUNCTION computeDic(): defined at Huffman.c:246
_computeDic	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: unsigned int
* Line Huffman.c:249: function call: huffInit()
	LBSR	_huffInit
* Line Huffman.c:250: function call: findOccurences()
	LDD	6,U		variable `iSize', declared at Huffman.c:246
	PSHS	B,A		argument 2 of findOccurences(): unsigned int
	LDD	4,U		variable `input', declared at Huffman.c:246
	PSHS	B,A		argument 1 of findOccurences(): unsigned char *
	LBSR	_findOccurences
	LEAS	4,S
* Line Huffman.c:251: function call: createTree()
	LEAX	_occurences+0,PCR	address of array occurences
	PSHS	X		argument 1 of createTree(): struct VALUE_STRUCT[]
	LBSR	_createTree
	LEAS	2,S
* Line Huffman.c:254: function call: updateDic()
	LDD	_occurencesCount+0,PCR	variable `occurencesCount', declared at Huffman.c:13
	PSHS	B,A		argument 3 of updateDic(): unsigned int
	LEAX	_occurences+0,PCR	address of array occurences
* optim: optimizePshsOps
	LDD	_rootNode+0,PCR	variable `rootNode', declared at Huffman.c:14
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_updateDic
	LEAS	6,S
* Useless label L00111 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION computeDic(): defined at Huffman.c:246
funcend_computeDic	EQU *
funcsize_computeDic	EQU	funcend_computeDic-_computeDic
_encodeDic	EXPORT


*******************************************************************************

* FUNCTION encodeDic(): defined at Huffman.c:257
_encodeDic	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-41,S
* Formal parameter(s):
*      4,U:    2 bytes: bf: struct bitFieldStruct *
* Local non-static variable(s):
*    -41,U:    2 bytes: j: int
*    -39,U:    1 byte : symbolLen: unsigned char
*    -38,U:    2 bytes: i: int
*    -36,U:    2 bytes: sz: unsigned int
*    -34,U:   32 bytes: symbolCode: unsigned char[]
*     -2,U:    1 byte : maxLen: unsigned char
*     -1,U:    1 byte : bitsReq: unsigned char
* Line Huffman.c:260: init of variable sz
	CLRA
	CLRB
	STD	-36,U		variable sz
* Line Huffman.c:263: function call: logOut()
	LDD	_occurencesCount+0,PCR	variable `occurencesCount', declared at Huffman.c:13
	PSHS	B,A		argument 3 of logOut(): unsigned int
	LEAX	S00118,PCR	"occurences count:%d"
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	6,S
* Line Huffman.c:264: function call: writebits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDD	_occurencesCount+0,PCR	variable `occurencesCount', declared at Huffman.c:13
	PSHS	B,A		argument 2 of writebits(): unsigned int
	LDD	4,U		variable `bf', declared at Huffman.c:257
	PSHS	B,A		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:265: assignment: +=
	LDD	-36,U		variable sz
	ADDD	#$08		+= operator at Huffman.c:265
	STD	-36,U
* Line Huffman.c:269: init of variable maxLen
	CLR	-2,U		variable maxLen
* Line Huffman.c:270: init of variable bitsReq
	CLR	-1,U		variable bitsReq
* Line Huffman.c:271: for init
* Line Huffman.c:271: init of variable i
	CLRA
	CLRB
	STD	-38,U		variable i
	BRA	L00226		jump to for condition
L00225	EQU	*
* Line Huffman.c:271: for body
* Line Huffman.c:272: if
	LDX	-38,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LBSR	isDWordZero
	BEQ	L00230
* optim: branchToNextLocation
* Useless label L00229 removed
* Line Huffman.c:272
* Line Huffman.c:274: init of variable symbolLen
* Line Huffman.c:274: function call: findDicCode()
	LEAX	-34,U		address of array symbolCode
	PSHS	X		argument 2 of findDicCode(): unsigned char[]
	LDX	-38,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of findDicCode(): unsigned char
	LBSR	_findDicCode
	LEAS	4,S
	STB	-39,U		variable symbolLen
* Line Huffman.c:275: if
* optim: storeLoad
	CMPB	-2,U		variable maxLen
	BLS	L00232		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00231 removed
* Line Huffman.c:276
* Line Huffman.c:276: assignment: =
	LDB	-39,U		variable `symbolLen', declared at Huffman.c:274
	STB	-2,U
L00232	EQU	*		else clause of if() started at Huffman.c:275
* Useless label L00233 removed
L00230	EQU	*		else clause of if() started at Huffman.c:272
* Useless label L00234 removed
* Useless label L00227 removed
* Line Huffman.c:271: for increment(s)
	LDD	-38,U
	ADDD	#1
	STD	-38,U
L00226	EQU	*
* Line Huffman.c:271: for condition
	LDD	-38,U		variable i
	CMPD	#$0100
	BLT	L00225
* optim: branchToNextLocation
* Useless label L00228 removed
* Line Huffman.c:280: assignment: =
* Line Huffman.c:280: function call: countBits()
	LDB	-2,U		variable `maxLen', declared at Huffman.c:269
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of countBits(): unsigned char
	LBSR	_countBits
	LEAS	2,S
	STB	-1,U
* Line Huffman.c:281: function call: logOut()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 4 of logOut(): unsigned char
	LDB	-2,U		variable `maxLen', declared at Huffman.c:269
* optim: stripExtraClrA_B
	PSHS	B,A		argument 3 of logOut(): unsigned char
	LEAX	S00119,PCR	"max length path:%d - bits required:%d"
* optim: optimizePshsOps
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	8,S
* Line Huffman.c:283: function call: writebits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDB	-2,U		variable `maxLen', declared at Huffman.c:269
* optim: stripExtraClrA_B
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LDD	4,U		variable `bf', declared at Huffman.c:257
	PSHS	B,A		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:284: assignment: +=
	LDD	-36,U		variable sz
	ADDD	#$08		+= operator at Huffman.c:284
	STD	-36,U
* Line Huffman.c:287: for init
* Line Huffman.c:287: init of variable i
	CLRA
	CLRB
	STD	-38,U		variable i
	LBRA	L00236		jump to for condition
L00235	EQU	*
* Line Huffman.c:287: for body
* Line Huffman.c:288: if
	LDX	-38,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LBSR	isDWordZero
	LBEQ	L00240
* optim: branchToNextLocation
* Useless label L00239 removed
* Line Huffman.c:288
* Line Huffman.c:290: function call: writebits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDX	-38,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LDD	4,U		variable `bf', declared at Huffman.c:257
	PSHS	B,A		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:291: assignment: +=
	LDD	-36,U		variable sz
	ADDD	#$08		+= operator at Huffman.c:291
	STD	-36,U
* Line Huffman.c:292: init of variable symbolLen
* Line Huffman.c:292: function call: findDicCode()
	LEAX	-34,U		address of array symbolCode
	PSHS	X		argument 2 of findDicCode(): unsigned char[]
	LDX	-38,U		variable i
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_occurences+0,PCR	address of array occurences
	LEAX	D,X		add offset
	LDB	4,X		member ch of VALUE_STRUCT
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of findDicCode(): unsigned char
	LBSR	_findDicCode
	LEAS	4,S
	STB	-39,U		variable symbolLen
* Line Huffman.c:293: function call: writebits()
	LDB	-1,U		variable `bitsReq', declared at Huffman.c:270
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of writebits(): unsigned char
	LDB	-39,U		variable `symbolLen', declared at Huffman.c:292
* optim: stripExtraClrA_B
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LDD	4,U		variable `bf', declared at Huffman.c:257
	PSHS	B,A		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:294: assignment: +=
	LDB	-1,U		variable `bitsReq', declared at Huffman.c:270
	CLRA
	ADDD	-36,U		optim: pushDLoadAdd
* 
* 
	STD	-36,U
* Line Huffman.c:295: for init
* Line Huffman.c:295: init of variable j
	CLRA
	CLRB
	STD	-41,U		variable j
	BRA	L00242		jump to for condition
L00241	EQU	*
* Line Huffman.c:295: for body
* Line Huffman.c:296: function call: writebits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDD	-41,U		variable j
	LEAX	-34,U		address of array symbolCode
	LEAX	D,X		add offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LDD	4,U		variable `bf', declared at Huffman.c:257
	PSHS	B,A		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:297: assignment: +=
	LDD	-36,U		variable sz
	ADDD	#$01		+= operator at Huffman.c:297
	STD	-36,U
* Useless label L00243 removed
* Line Huffman.c:295: for increment(s)
	LDD	-41,U
	ADDD	#1
	STD	-41,U
L00242	EQU	*
* Line Huffman.c:295: for condition
	LDB	-39,U		variable `symbolLen', declared at Huffman.c:292
	CLRA			promotion of binary operand
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-41,U		optim: optimize16BitCompares
	BHI	L00241		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label L00244 removed
L00240	EQU	*		else clause of if() started at Huffman.c:288
* Useless label L00245 removed
* Useless label L00237 removed
* Line Huffman.c:287: for increment(s)
	LDD	-38,U
	ADDD	#1
	STD	-38,U
L00236	EQU	*
* Line Huffman.c:287: for condition
	LDD	-38,U		variable i
	CMPD	#$0100
	LBLT	L00235
* optim: branchToNextLocation
* Useless label L00238 removed
* Line Huffman.c:303: function call: logOut()
	LDX	4,U		variable bf
	LDD	2,X		member currentIndex of bitFieldStruct
	PSHS	B,A		argument 5 of logOut(): unsigned int
	LDD	-36,U		to be divided by 8
	LSRA
	RORB
	LSRA
	RORB
	LSRA
	RORB
	PSHS	B,A		argument 4 of logOut(): unsigned int
	LDD	-36,U		variable `sz', declared at Huffman.c:260
	PSHS	B,A		argument 3 of logOut(): unsigned int
	LEAX	S00120,PCR	"Dictionnary size:%d bits (%d bytes) - %d"
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	10,S
* Useless label L00112 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION encodeDic(): defined at Huffman.c:257
funcend_encodeDic	EQU *
funcsize_encodeDic	EQU	funcend_encodeDic-_encodeDic
_decodeDic	EXPORT


*******************************************************************************

* FUNCTION decodeDic(): defined at Huffman.c:307
_decodeDic	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-16,S
* Formal parameter(s):
*      4,U:    2 bytes: dic: struct bitFieldStruct *
*      6,U:    2 bytes: root: struct NODE_STRUCT *
*      8,U:    2 bytes: backValues: struct VALUE_STRUCT *
*     10,U:    2 bytes: backValuesSize: unsigned int
* Local non-static variable(s):
*    -16,U:    2 bytes: n: struct NODE_STRUCT *
*    -14,U:    1 byte : bit: unsigned char
*    -13,U:    2 bytes: i: int
*    -11,U:    2 bytes: occCount: unsigned int
*     -9,U:    1 byte : maxLen: unsigned char
*     -8,U:    1 byte : bitsReq: unsigned char
*     -7,U:    1 byte : symbol: unsigned char
*     -6,U:    2 bytes: symbolLen: unsigned int
*     -4,U:    2 bytes: backValuesIdx: unsigned int
*     -2,U:    2 bytes: parent: struct NODE_STRUCT *
* Line Huffman.c:310: init of variable occCount
* Line Huffman.c:310: function call: readbits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 2 of readbits(): int
	LDD	4,U		variable `dic', declared at Huffman.c:307
	PSHS	B,A		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
	STD	-11,U		variable occCount
* Line Huffman.c:311: function call: logOut()
* optim: storeLoad
	PSHS	B,A		argument 3 of logOut(): unsigned int
	LEAX	S00118,PCR	"occurences count:%d"
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	6,S
* Line Huffman.c:314: init of variable maxLen
* Line Huffman.c:314: function call: readbits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 2 of readbits(): int
	LDD	4,U		variable `dic', declared at Huffman.c:307
	PSHS	B,A		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* Cast from `unsigned int' to byte: result already in B
	STB	-9,U		variable maxLen
* Line Huffman.c:315: init of variable bitsReq
* Line Huffman.c:315: function call: countBits()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of countBits(): unsigned char
	LBSR	_countBits
	LEAS	2,S
	STB	-8,U		variable bitsReq
* Line Huffman.c:316: function call: logOut()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 4 of logOut(): unsigned char
	LDB	-9,U		variable `maxLen', declared at Huffman.c:314
* optim: stripExtraClrA_B
	PSHS	B,A		argument 3 of logOut(): unsigned char
	LEAX	S00119,PCR	"max length path:%d - bits required:%d"
* optim: optimizePshsOps
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_logOut
	LEAS	8,S
* Line Huffman.c:321: init of variable backValuesIdx
	CLRA
	CLRB
	STD	-4,U		variable backValuesIdx
* Line Huffman.c:322: init of variable parent
	LDD	6,U		variable `root', declared at Huffman.c:307
	STD	-2,U		variable parent
* Line Huffman.c:324: while
	LBRA	L00247		jump to while condition
L00246	EQU	*		while body
* Line Huffman.c:325: assignment: =
* Line Huffman.c:325: function call: readbits()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 2 of readbits(): int
	LDD	4,U		variable `dic', declared at Huffman.c:307
	PSHS	B,A		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* Cast from `unsigned int' to byte: result already in B
	STB	-7,U
* Line Huffman.c:328: assignment: =
* Line Huffman.c:328: function call: readbits()
	LDB	-8,U		variable `bitsReq', declared at Huffman.c:315
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readbits(): unsigned char
	LDD	4,U		variable `dic', declared at Huffman.c:307
	PSHS	B,A		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
	STD	-6,U
* Line Huffman.c:332: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	6,U
	STD	-2,U
* Line Huffman.c:333: for init
* Line Huffman.c:333: init of variable i
	CLRA
	CLRB
	STD	-13,U		variable i
	LBRA	L00250		jump to for condition
L00249	EQU	*
* Line Huffman.c:333: for body
* Line Huffman.c:334: init of variable bit
* Line Huffman.c:334: function call: readbits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 2 of readbits(): int
	LDD	4,U		variable `dic', declared at Huffman.c:307
	PSHS	B,A		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* Cast from `unsigned int' to byte: result already in B
	STB	-14,U		variable bit
* Line Huffman.c:337: if
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	LBEQ	L00254		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00253 removed
* Line Huffman.c:337
* Line Huffman.c:338: if
	LDD	-6,U		variable symbolLen
	ADDD	#$FFFF		65535
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-13,U		optim: optimize16BitCompares
	BNE	L00256		optim: optimize16BitCompares (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00255 removed
* Line Huffman.c:339
* Line Huffman.c:339: assignment: =
	LDB	-7,U		variable `symbol', declared at Huffman.c:319
	PSHS	B
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
* optim: optimizeLeax
	LDB	,S+
	STB	4,X		optim: optimizeLeax
	BRA	L00257		jump over else clause
L00256	EQU	*		else clause of if() started at Huffman.c:338
* Line Huffman.c:341
* Line Huffman.c:341: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
* optim: optimizeLeax
	LDB	,S+
	STB	4,X		optim: optimizeLeax
L00257	EQU	*		end of if() started at Huffman.c:338
* Line Huffman.c:342: assignment: =
	CLRA
	CLRB
	PSHS	B,A		preserve right side of assignment
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
	PULS	A,B		restore right side of assignment
	LBSR	initDWordFromSignedWord
* Line Huffman.c:345: if
	LDX	-2,U		variable parent
	LDD	7,X		member right of NODE_STRUCT
* optim: loadCmpZeroBeqOrBne
	BEQ	L00259		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00258 removed
* Line Huffman.c:345
* Line Huffman.c:346: assignment: =
	LDX	-2,U		variable parent
	LDD	7,X		member right of NODE_STRUCT
	STD	-16,U
	BRA	L00260		jump over else clause
L00259	EQU	*		else clause of if() started at Huffman.c:345
* Line Huffman.c:347
* Line Huffman.c:348: assignment: =
* Line Huffman.c:348: function call: createNode()
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
	TFR	X,D		address-of operator
* Emitted no code to cast `struct VALUE_STRUCT *' to `void *'
	PSHS	B,A		argument 1 of createNode(): void *
	LBSR	_createNode
	LEAS	2,S
	STD	-16,U
* Line Huffman.c:349: post-increment
	LDX	-4,U		variable `backValuesIdx', declared at Huffman.c:349
	LEAX	1,X
	STX	-4,U
L00260	EQU	*		end of if() started at Huffman.c:345
* Line Huffman.c:351: function call: addChildRight()
	LDD	-16,U		variable `n', declared at Huffman.c:344
	PSHS	B,A		argument 2 of addChildRight(): struct NODE_STRUCT *
	LDD	-2,U		variable `parent', declared at Huffman.c:322
	PSHS	B,A		argument 1 of addChildRight(): struct NODE_STRUCT *
	LBSR	_addChildRight
	LEAS	4,S
* Line Huffman.c:354: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-16,U
	STD	-2,U
	LBRA	L00261		jump over else clause
L00254	EQU	*		else clause of if() started at Huffman.c:337
* Line Huffman.c:355
* Line Huffman.c:356: if
	LDD	-6,U		variable symbolLen
	ADDD	#$FFFF		65535
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-13,U		optim: optimize16BitCompares
	BNE	L00263		optim: optimize16BitCompares (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00262 removed
* Line Huffman.c:357
* Line Huffman.c:357: assignment: =
	LDB	-7,U		variable `symbol', declared at Huffman.c:319
	PSHS	B
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
* optim: optimizeLeax
	LDB	,S+
	STB	4,X		optim: optimizeLeax
	BRA	L00264		jump over else clause
L00263	EQU	*		else clause of if() started at Huffman.c:356
* Line Huffman.c:359
* Line Huffman.c:359: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
* optim: optimizeLeax
	LDB	,S+
	STB	4,X		optim: optimizeLeax
L00264	EQU	*		end of if() started at Huffman.c:356
* Line Huffman.c:360: assignment: =
	CLRA
	CLRB
	PSHS	B,A		preserve right side of assignment
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
	PULS	A,B		restore right side of assignment
	LBSR	initDWordFromSignedWord
* Line Huffman.c:363: if
	LDX	-2,U		variable parent
	LDD	5,X		member left of NODE_STRUCT
* optim: loadCmpZeroBeqOrBne
	BEQ	L00266		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00265 removed
* Line Huffman.c:363
* Line Huffman.c:364: assignment: =
	LDX	-2,U		variable parent
	LDD	5,X		member left of NODE_STRUCT
	STD	-16,U
	BRA	L00267		jump over else clause
L00266	EQU	*		else clause of if() started at Huffman.c:363
* Line Huffman.c:365
* Line Huffman.c:366: assignment: =
* Line Huffman.c:366: function call: createNode()
	LDX	-4,U		variable backValuesIdx
	LDB	#5		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	8,U		pointer backValues
	LEAX	D,X		add offset
	TFR	X,D		address-of operator
* Emitted no code to cast `struct VALUE_STRUCT *' to `void *'
	PSHS	B,A		argument 1 of createNode(): void *
	LBSR	_createNode
	LEAS	2,S
	STD	-16,U
* Line Huffman.c:367: post-increment
	LDX	-4,U		variable `backValuesIdx', declared at Huffman.c:367
	LEAX	1,X
	STX	-4,U
L00267	EQU	*		end of if() started at Huffman.c:363
* Line Huffman.c:369: function call: addChildLeft()
	LDD	-16,U		variable `n', declared at Huffman.c:362
	PSHS	B,A		argument 2 of addChildLeft(): struct NODE_STRUCT *
	LDD	-2,U		variable `parent', declared at Huffman.c:322
	PSHS	B,A		argument 1 of addChildLeft(): struct NODE_STRUCT *
	LBSR	_addChildLeft
	LEAS	4,S
* Line Huffman.c:372: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-16,U
	STD	-2,U
L00261	EQU	*		end of if() started at Huffman.c:337
* Useless label L00251 removed
* Line Huffman.c:333: for increment(s)
	LDD	-13,U
	ADDD	#1
	STD	-13,U
L00250	EQU	*
* Line Huffman.c:333: for condition
	LDD	-13,U		variable i
	CMPD	-6,U		variable symbolLen
	LBLO	L00249
* optim: branchToNextLocation
* Useless label L00252 removed
* Line Huffman.c:376: post-decrement
	LDX	-11,U		variable `occCount', declared at Huffman.c:376
	LEAX	-1,X
	STX	-11,U
L00247	EQU	*		while condition at Huffman.c:324
	LDD	-11,U		variable `occCount', declared at Huffman.c:310
* optim: loadCmpZeroBeqOrBne
	LBNE	L00246
* optim: branchToNextLocation
* Useless label L00248 removed
* Useless label L00113 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION decodeDic(): defined at Huffman.c:307
funcend_decodeDic	EQU *
funcsize_decodeDic	EQU	funcend_decodeDic-_decodeDic
_compress	EXPORT


*******************************************************************************

* FUNCTION compress(): defined at Huffman.c:382
_compress	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-20,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: unsigned int
*      8,U:    2 bytes: output: unsigned char *
*     10,U:    2 bytes: oSize: unsigned int
*     12,U:    2 bytes: wtd: int
* Local non-static variable(s):
*    -20,U:    1 byte : bit: unsigned char
*    -19,U:    2 bytes: j: int
*    -17,U:    1 byte : symbolLen: unsigned char
*    -16,U:    2 bytes: i: int
*    -14,U:    5 bytes: bfOut: struct bitFieldStruct
*     -9,U:    4 bytes: code: unsigned char[]
*     -5,U:    5 bytes: bfCode: struct bitFieldStruct
* Line Huffman.c:385: function call: memset()
	LDD	10,U		variable `oSize', declared at Huffman.c:382
	PSHS	B,A		argument 3 of memset(): unsigned int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LDD	8,U		variable `output', declared at Huffman.c:382
	PSHS	B,A		argument 1 of memset(): unsigned char *
	LBSR	_memset
	LEAS	6,S
* Line Huffman.c:387: function call: initBitField()
	LDD	8,U		variable `output', declared at Huffman.c:382
	PSHS	B,A		argument 2 of initBitField(): unsigned char *
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of initBitField(): struct bitFieldStruct *
	LBSR	_initBitField
	LEAS	4,S
* Line Huffman.c:390: if
	LDD	12,U		variable wtd
	CMPD	#$01
	BNE	L00269		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00268 removed
* Line Huffman.c:390
* Line Huffman.c:392: function call: writebits()
	LDX	#$01		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:394: function call: computeDic()
	LDD	6,U		variable `iSize', declared at Huffman.c:382
	PSHS	B,A		argument 2 of computeDic(): unsigned int
	LDD	4,U		variable `input', declared at Huffman.c:382
	PSHS	B,A		argument 1 of computeDic(): unsigned char *
	LBSR	_computeDic
	LEAS	4,S
* Line Huffman.c:396: function call: encodeDic()
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of encodeDic(): struct bitFieldStruct *
	LBSR	_encodeDic
	LEAS	2,S
	BRA	L00270		jump over else clause
L00269	EQU	*		else clause of if() started at Huffman.c:390
* Line Huffman.c:405
* Line Huffman.c:397: if
	LDD	12,U		variable wtd
	CMPD	#$02
	BNE	L00272		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00271 removed
* Line Huffman.c:397
* Line Huffman.c:399: function call: writebits()
	LDX	#$01		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:401: function call: encodeDic()
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of encodeDic(): struct bitFieldStruct *
	LBSR	_encodeDic
	LEAS	2,S
	BRA	L00273		jump over else clause
L00272	EQU	*		else clause of if() started at Huffman.c:397
* Line Huffman.c:402
* Line Huffman.c:404: function call: writebits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of writebits(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		argument 2 of writebits(): int
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
L00273	EQU	*		end of if() started at Huffman.c:397
L00270	EQU	*		end of if() started at Huffman.c:390
* Line Huffman.c:408: function call: writebits()
	LDX	#$10		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable `iSize', declared at Huffman.c:382
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Line Huffman.c:413: function call: initBitField()
	LEAY	-9,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-5,U		variable `bfCode', declared at Huffman.c:412
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line Huffman.c:415: for init
* Line Huffman.c:415: init of variable i
	CLRA
	CLRB
	STD	-16,U		variable i
	LBRA	L00275		jump to for condition
L00274	EQU	*
* Line Huffman.c:415: for body
* Line Huffman.c:416: init of variable symbolLen
	LDD	-16,U		variable i
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
* optim: stripOpToDeadReg
	LDA	#5		size of array element
	MUL			get offset in bytes in D
	LEAX	_dictionary+0,PCR	address of array dictionary
	LEAX	D,X		add offset
	LDB	4,X		member bitsLen of DICTIONARY_STRUCT
	STB	-17,U		variable symbolLen
* Line Huffman.c:419: function call: memcpy()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		argument 3 of memcpy(): int
	LDD	-16,U		variable i
	LDX	4,U		pointer input
* optimizeLoadDX
	LDB	D,X		get r-value
* optim: stripOpToDeadReg
	LDA	#5		size of array element
	MUL			get offset in bytes in D
	LEAX	_dictionary+0,PCR	address of array dictionary
	LEAX	D,X		add offset
	LEAX	,X		member code of DICTIONARY_STRUCT
	TFR	X,D
	PSHS	B,A		argument 2 of memcpy(): unsigned char[]
	LEAX	-9,U		address of array code
	PSHS	X		argument 1 of memcpy(): unsigned char[]
	LBSR	_memcpy
	LEAS	6,S
* Line Huffman.c:420: function call: initBitField()
	LEAY	-9,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-5,U		variable `bfCode', declared at Huffman.c:412
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_initBitField
	LEAS	4,S
* Line Huffman.c:422: for init
* Line Huffman.c:422: init of variable j
	CLRA
	CLRB
	STD	-19,U		variable j
	BRA	L00279		jump to for condition
L00278	EQU	*
* Line Huffman.c:422: for body
* Line Huffman.c:423: init of variable bit
* Line Huffman.c:423: function call: readbits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 2 of readbits(): int
	LEAX	-5,U		variable `bfCode', declared at Huffman.c:412
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* Cast from `unsigned int' to byte: result already in B
	STB	-20,U		variable bit
* Line Huffman.c:424: function call: writebits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of writebits(): int
	LDB	-20,U		variable `bit', declared at Huffman.c:423
* optim: stripExtraClrA_B
	PSHS	B,A		argument 2 of writebits(): unsigned char
	LEAX	-14,U		variable `bfOut', declared at Huffman.c:386
	PSHS	X		argument 1 of writebits(): struct bitFieldStruct *
	LBSR	_writebits
	LEAS	6,S
* Useless label L00280 removed
* Line Huffman.c:422: for increment(s)
	LDD	-19,U
	ADDD	#1
	STD	-19,U
L00279	EQU	*
* Line Huffman.c:422: for condition
	LDB	-17,U		variable `symbolLen', declared at Huffman.c:416
	CLRA			promotion of binary operand
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-19,U		optim: optimize16BitCompares
	BHI	L00278		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label L00281 removed
* Useless label L00276 removed
* Line Huffman.c:415: for increment(s)
	LDD	-16,U
	ADDD	#1
	STD	-16,U
L00275	EQU	*
* Line Huffman.c:415: for condition
	LDD	-16,U		variable i
	CMPD	6,U		variable iSize
	LBLO	L00274
* optim: branchToNextLocation
* Useless label L00277 removed
* Line Huffman.c:429: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	ADDD	-12,U		optim: pushDLoadAdd
* 
* 
* Emitted no code to cast `unsigned int' to `int'
* optim: branchToNextLocation
* Useless label L00114 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION compress(): defined at Huffman.c:382
funcend_compress	EQU *
funcsize_compress	EQU	funcend_compress-_compress
_uncompress	EXPORT


*******************************************************************************

* FUNCTION uncompress(): defined at Huffman.c:433
_uncompress	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-15,S
* Formal parameter(s):
*      4,U:    2 bytes: input: unsigned char *
*      6,U:    2 bytes: iSize: unsigned int
*      8,U:    2 bytes: output: unsigned char *
*     10,U:    2 bytes: oSize: unsigned int
* Local non-static variable(s):
*    -15,U:    1 byte : bit: unsigned char
*    -14,U:    2 bytes: currentNode: struct NODE_STRUCT *
*    -12,U:    2 bytes: i: int
*    -10,U:    5 bytes: bfIn: struct bitFieldStruct
*     -5,U:    2 bytes: outputIdx: unsigned int
*     -3,U:    1 byte : isThereADic: unsigned char
*     -2,U:    2 bytes: nodeCount: unsigned int
* Line Huffman.c:436: function call: memset()
	LDD	10,U		variable `oSize', declared at Huffman.c:433
	PSHS	B,A		argument 3 of memset(): unsigned int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of memset(): int
	LDD	8,U		variable `output', declared at Huffman.c:433
	PSHS	B,A		argument 1 of memset(): unsigned char *
	LBSR	_memset
	LEAS	6,S
* Line Huffman.c:437: function call: initBitField()
	LDD	4,U		variable `input', declared at Huffman.c:433
	PSHS	B,A		argument 2 of initBitField(): unsigned char *
	LEAX	-10,U		variable `bfIn', declared at Huffman.c:435
	PSHS	X		argument 1 of initBitField(): struct bitFieldStruct *
	LBSR	_initBitField
	LEAS	4,S
* Line Huffman.c:438: init of variable outputIdx
	CLRA
	CLRB
	STD	-5,U		variable outputIdx
* Line Huffman.c:440: init of variable isThereADic
* Line Huffman.c:440: function call: readbits()
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A		argument 2 of readbits(): int
	LEAX	-10,U		variable `bfIn', declared at Huffman.c:435
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
	STB	-3,U		variable isThereADic
* Line Huffman.c:441: if
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	BEQ	L00283		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00282 removed
* Line Huffman.c:441
* Line Huffman.c:442: function call: huffInit()
	LBSR	_huffInit
* Line Huffman.c:443: assignment: =
	CLRA
	CLRB
* Emitted no code to cast `int' to `void *'
* optim: stripUselessPushPull
	LDX	_rootNode+0,PCR	variable rootNode
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	7,X		optim: optimizeLeax
* Line Huffman.c:444: assignment: =
* optim: removeClr
* optim: removeClr
* Emitted no code to cast `int' to `void *'
* optim: stripUselessPushPull
* optim: removeRepeatedLDX
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	5,X		optim: optimizeLeax
* Line Huffman.c:445: function call: decodeDic()
	LDD	#$01FF		decimal 511 signed
	PSHS	B,A		argument 4 of decodeDic(): int
	LEAX	_occurences+0,PCR	address of array occurences
* optim: optimizePshsOps
	LDD	_rootNode+0,PCR	variable `rootNode', declared at Huffman.c:14
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-10,U		variable `bfIn', declared at Huffman.c:435
	PSHS	X		argument 1 of decodeDic(): struct bitFieldStruct *
	LBSR	_decodeDic
	LEAS	8,S
L00283	EQU	*		else clause of if() started at Huffman.c:441
* Useless label L00284 removed
* Line Huffman.c:448: init of variable nodeCount
* Line Huffman.c:448: function call: readbits()
	CLRA
	LDB	#$10		constant expression: 16 decimal, unsigned
	PSHS	B,A		argument 2 of readbits(): unsigned int
	LEAX	-10,U		variable `bfIn', declared at Huffman.c:435
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
	STD	-2,U		variable nodeCount
* Line Huffman.c:450: for init
* Line Huffman.c:450: init of variable i
	CLRA
	CLRB
	STD	-12,U		variable i
	LBRA	L00286		jump to for condition
L00285	EQU	*
* Line Huffman.c:450: for body
* Line Huffman.c:451: init of variable currentNode
	LDD	_rootNode+0,PCR	variable `rootNode', declared at Huffman.c:14
	STD	-14,U		variable currentNode
* Line Huffman.c:453: while
	BRA	L00290		jump to while condition
L00289	EQU	*		while body
* Line Huffman.c:454: init of variable bit
* Line Huffman.c:454: function call: readbits()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 2 of readbits(): int
	LEAX	-10,U		variable `bfIn', declared at Huffman.c:435
	PSHS	X		argument 1 of readbits(): struct bitFieldStruct *
	LBSR	_readbits
	LEAS	4,S
* Cast from `unsigned int' to byte: result already in B
	STB	-15,U		variable bit
* Line Huffman.c:456: if
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	BEQ	L00293		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00292 removed
* Line Huffman.c:456
* Line Huffman.c:457: assignment: =
	LDX	-14,U		variable currentNode
	LDD	7,X		member right of NODE_STRUCT
	STD	-14,U
	BRA	L00294		jump over else clause
L00293	EQU	*		else clause of if() started at Huffman.c:456
* Line Huffman.c:458
* Line Huffman.c:459: assignment: =
	LDX	-14,U		variable currentNode
	LDD	5,X		member left of NODE_STRUCT
	STD	-14,U
L00294	EQU	*		end of if() started at Huffman.c:456
L00290	EQU	*		while condition at Huffman.c:453
	CLRA
* optim: removeUselessClrb
* Emitted no code to cast `int' to `void *'
* PSHS B,A optim: optimizeStackOperations1
	LDX	-14,U		variable currentNode
	LDD	5,X		member left of NODE_STRUCT
* optim: loadCmpZeroBeqOrBne
	BNE	L00289
* optim: branchToNextLocation
* Useless label L00295 removed
	CLRA
* optim: removeUselessClrb
* Emitted no code to cast `int' to `void *'
* PSHS B,A optim: optimizeStackOperations1
	LDX	-14,U		variable currentNode
	LDD	7,X		member right of NODE_STRUCT
* optim: loadCmpZeroBeqOrBne
	BNE	L00289
* optim: branchToNextLocation
* Useless label L00291 removed
* Line Huffman.c:463: assignment: =
	LDX	-14,U		variable currentNode
	LDD	3,X		member pValue of NODE_STRUCT
* Emitted no code to cast `void *' to `struct VALUE_STRUCT *'
	TFR	D,X
	LDB	4,X		member ch of VALUE_STRUCT
	PSHS	B
	LDD	-5,U		variable `outputIdx', declared at Huffman.c:463
	ADDD	#1
	STD	-5,U
	SUBD	#1		post increment yields initial value
	LDX	8,U		pointer output
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Useless label L00287 removed
* Line Huffman.c:450: for increment(s)
	LDD	-12,U
	ADDD	#1
	STD	-12,U
L00286	EQU	*
* Line Huffman.c:450: for condition
	LDD	-12,U		variable i
	CMPD	-2,U		variable nodeCount
	LBLO	L00285
* optim: branchToNextLocation
* Useless label L00288 removed
* Line Huffman.c:469: return with value
	LDD	-5,U		variable `outputIdx', declared at Huffman.c:438
* Emitted no code to cast `unsigned int' to `int'
* optim: branchToNextLocation
* Useless label L00115 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION uncompress(): defined at Huffman.c:433
funcend_uncompress	EQU *
funcsize_uncompress	EQU	funcend_uncompress-_uncompress


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00116	EQU	*
	FCC	"occurences array memory size:%d bytes"
	FCB	0
S00117	EQU	*
	FCC	"dictionary array memory size:%d bytes"
	FCB	0
S00118	EQU	*
	FCC	"occurences count:%d"
	FCB	0
S00119	EQU	*
	FCC	"max length path:%d - bits required:%d"
	FCB	0
S00120	EQU	*
	FCC	"Dictionnary size:%d bits (%d bytes) - %d"
	FCB	0
string_literals_end	EQU	*
dword_constants_start	EQU	*


*******************************************************************************

* DWORD CONSTANTS
D00138	EQU	*
	FCB	$FF,$FF,$00,$00
dword_constants_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
_occurencesCount	EQU	*		occurencesCount: unsigned int
	FDB	$00		decimal 0
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
_occurences	EQU	*
	RMB	2555		occurences
_rootNode	EQU	*
	RMB	2		rootNode
_dictionary	EQU	*
	RMB	1280		dictionary
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 21 utility routine(s).
MUL16	IMPORT
MUL168	IMPORT
_addChildLeft	IMPORT
_addChildRight	IMPORT
_createNode	IMPORT
_initBitField	IMPORT
_logOut	IMPORT
_memcpy	IMPORT
_memset	IMPORT
_readbits	IMPORT
_treeInit	IMPORT
_writebits	IMPORT
addDWordDWord	IMPORT
andDWordDWord	IMPORT
andDWordWord	IMPORT
copyDWord	IMPORT
incrementDWord	IMPORT
initDWordFromSignedWord	IMPORT
isDWordZero	IMPORT
push4ByteStruct	IMPORT
rightShiftDWord	IMPORT


*******************************************************************************

	END
